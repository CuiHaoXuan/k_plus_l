# -*- coding: utf-8 -*-

"""
This file is to create ampl data file for different optimization models
model 1: minimum cost routing (mcr)
model 2: load balancing (lb)
model 3: average network delay (avg_delay)

The input file is a path file generated by matlab. The path file contains 
information:
    - The number of node, the number of path for each node-pair
    - node pair : path between the node pair

The output file is ampl data file *.dat

By Xuan Liu
Dec. 17, 2013
"""
import random
import numpy as np
#import sys
#from optparse import OptionParser
import json

def parse_file(path_lib):
    """
    Parse the path file
    """
    fhandle = open(path_lib, 'r')
    lines = []
    for line in fhandle.readlines():
        lines.append(line)
    num_nodes = int(lines[0].split()[0])
    path_dict = {}
    for item in lines[2:]:
        path_info = item.split(':')
        path_id = int(path_info[0].split()[-1])
        path_src_dst = (int(path_info[1].split()[0]), 
                        int(path_info[1].split()[1]))
        path_link = path_info[2].split()[0]
        dict_key = path_src_dst
        
        if path_id == 1:
            path_dict[dict_key] = {}
            path_dict[dict_key][path_id] = path_link
        else:
            path_dict[dict_key][path_id] = path_link
        
    return num_nodes, path_dict
        
    
def get_links(weight_csv):
    """
    read the weight csv file, and get the connectivity information as matrix
    """
    link_matrix = np.genfromtxt(weight_csv, dtype=None, delimiter=',')
    link_dict = {}
    key = 1
    length = len(link_matrix)
    for row in range(length):
        for col in range(length):
            if link_matrix[row][col] != float('inf') and col < row:
                #print link_matrix[row][col]
                link_dict[key] = (row+1, col+1)
                key += 1
    return link_dict
                
    
def demand_gen(demand_type="uniform", demand_pair=None, fixed_vol=100):
    """
    Generate flow demand for each demand pair
    the demand_type is uniform or nonuniform
    demand_pair is in tuple form (src, dst)
    The return value is a dict, for example:
    {(1,2): 10, (1,3): 10, (2,3):10}
    """
    demand_dict = {}
    if demand_type == "uniform":
        # fixed load
        demand_vol = fixed_vol
        for pair in demand_pair:
            demand_dict[pair] = demand_vol
    elif demand_type == "nonuniform":
        for pair in demand_pair:
            demand_dict[pair] = random.randint(1,10)
    return demand_dict
    
    
def print_header(ampl_data_file, model_type, topo_type, num_nodes, demand_type):
    """
    print header including basic information about the data file
    model_type: mcr (minimal cost routing)
                lb (load balancing)
                avg_net_delay (average netwok delay)
    Topo_type: random/ring/grid/full/rocketfuel
    num_nodes
    demand_type: uniform(fixed)/nonuniform
    
    """
    fopen = open(ampl_data_file, 'w')
    header = """
    ## -- AMPL Data File --
    # Model: {0}
    # Topology: {1}
    # Number of Nodes: {2}
    # Demand Colume: {3}
    """.format(model_type, topo_type, num_nodes, demand_type)
    fopen.write(header)
    fopen.close()
    
def print_boundary(ampl_data_file, num_paths, num_nodes, 
                   link_dict, demand_allpair, sub_dmd=None):
    """
    Print set boundary parameters: D, L, N, Pd
    """
    if sub_dmd == None:
        pass
    else:
        demand_allpair = sub_dmd
    num_demand = len(demand_allpair)
    num_link = len(link_dict)
    matrix_str = '\t\t'.join([str(1), str(num_paths)]) + '\n'
    
    # generate demand-pair tuple array
    # for example: demand-pair 1 has 5 paths, then record as '1  5'
    for index in range(2, num_demand + 1):
        temp_str = '\t' + '\t\t'.join([str(index), str(num_paths)]) + '\n'
        matrix_str = matrix_str + temp_str
    
    bound_param = """
    ## -- Defind Set Boundary Parameter --
    param D := {0};
    param L := {1};
    param N := {2};
    param Pd :=
    {3}\t;
    """.format(num_demand, num_link, num_nodes, matrix_str)
    
    fopen = open(ampl_data_file, 'a')
    fopen.write(bound_param)
    fopen.close()
    
    
def print_link_node_pair(ampl_data_file, link_dict):
    """
    Print link node-pair parameter
    """
    # generate link node pair array
    # for example: link 1 is from node 1 to 2, then record as '1    1   2'    
    
    matrix_str = '\t\t\t'.join([str(1), 
                                str(link_dict[1][0]), 
                                str(link_dict[1][1])]) + '\n'
    for index in range(2, len(link_dict) + 1):
        temp_str = '\t' + '\t\t\t'.join([str(index), 
                                         str(link_dict[index][0]), 
                                         str(link_dict[index][1])]) + '\n'
        matrix_str = matrix_str + temp_str                                
    
    
    link_node_param = """
    ## -- Define Link Node-Pair Parameter --
    param: link_src     link_dst :=
    {0}\t;
    """.format(matrix_str)
    fopen = open(ampl_data_file, 'a')
    fopen.write(link_node_param)
    fopen.close()


def print_geant_demand_pair(ampl_data_file, demand_dict):
    """
    print demand node-pair in geant network, not all-pairs
    """
    d_pairs = demand_dict.keys()
    d_pairs.sort()
    matrix_str = '\t\t\t'.join([str(1), 
                                str(d_pairs[0][0]), 
                                str(d_pairs[0][1])]) + '\n'
                                
    for index in range(1, len(d_pairs)):
        temp_str = '\t' + '\t\t\t'.join([str(index+1), 
                                         str(d_pairs[index][0]), 
                                         str(d_pairs[index][1])]) + '\n'  
        matrix_str = matrix_str + temp_str                                 
                                         
    demand_node_param = """
    ## -- Define Demand Node-Pair Parameter --
    param: demand_src   demand_dst :=
    {0}\t;
    """.format(matrix_str)
    
    fopen = open(ampl_data_file, 'a')
    fopen.write(demand_node_param)
    fopen.close()
    

def print_demand_node_pair(ampl_data_file, d_allpairs, sub_dmd=None):
    """
    Print Demand Node-Pair Parameters
    """
    if sub_dmd == None:
        pass
    else:
        d_allpairs = sub_dmd
    d_allpairs.sort()
    matrix_str = '\t\t\t'.join([str(1), 
                                str(d_allpairs[0][0]), 
                                str(d_allpairs[0][1])]) + '\n'
                                
    for index in range(1, len(d_allpairs)):
        temp_str = '\t' + '\t\t\t'.join([str(index+1), 
                                         str(d_allpairs[index][0]), 
                                         str(d_allpairs[index][1])]) + '\n'  
        matrix_str = matrix_str + temp_str                                 
                                         
    demand_node_param = """
    ## -- Define Demand Node-Pair Parameter --
    param: demand_src   demand_dst :=
    {0}\t;
    """.format(matrix_str)
    
    fopen = open(ampl_data_file, 'a')
    fopen.write(demand_node_param)
    fopen.close()
    
def print_link_capacity(ampl_data_file, link_dict, link_capacity):
    """
    Print link capacity parameter
    """    
    matrix_str = '\t\t\t'.join([str(1), 
                                str(link_capacity)]) + '\n'
    for index in range(2, len(link_dict) + 1):
        temp_str = '\t' + '\t\t\t'.join([str(index), 
                                         str(link_capacity)]) + '\n'
        matrix_str = matrix_str + temp_str
        
    link_capacity_param = """
    ## -- Link Capacity Parameter --
    param link_capacity :=
    {0}\t;
    """.format(matrix_str)
    fopen = open(ampl_data_file, 'a')
    fopen.write(link_capacity_param)
    fopen.close()
    

def print_flow_cost(ampl_data_file, path_dict, cost_type, num_paths, 
                    sub_dmd=None, seed_val=2):
    """
    print the unit cost of flow on path for demand d
    Example:
            (path#) 1     2 
    (demand #)
        1           1     2
        2           1     2
        3           1     2
        ...
    There are two ways to assign the cost (cost_type):
    1. The cost is proportional to the number of hops in the path
    2. Randomly assign cost to each flow variable x
    """
    if sub_dmd == None:
        d_allpairs = path_dict.keys()
    else:
        d_allpairs = sub_dmd
    d_allpairs.sort()
    #print d_allpairs
    
    path_seq = map(str, range(1, num_paths + 1))
    path_seq = '\t\t\t'.join(path_seq)
    
    matrix_str = ''
    if cost_type == "byhops":
        # the cost proportional to the number of hops along a path
        for index in range(len(d_allpairs)):
            cost_list = []
            cost_list.append(str(index + 1))
            for item in path_dict[d_allpairs[index]]:
                cost = count_hop(path_dict[d_allpairs[index]][item])
                cost_list.append(str(cost))
            if index == 0:
                temp_str = '\t\t\t'.join(cost_list) + '\n'
            else: 
                temp_str = '\t' + '\t\t\t'.join(cost_list) + '\n'
            matrix_str = matrix_str + temp_str
    elif cost_type == "rand":
        # randomly assign cost
        random.seed(seed_val)
        for index in range(len(d_allpairs)):
            cost_list = []
            cost_list.append(str(index + 1))
            for item in path_dict[d_allpairs[index]]:
                cost = random.uniform(1,100)
                cost_list.append(str(cost))
            if index == 0:
                temp_str = '\t\t\t'.join(cost_list) + '\n'
            else: 
                temp_str = '\t' + '\t\t\t'.join(cost_list) + '\n'
            matrix_str = matrix_str + temp_str
            
    flow_cost_param = """
    ## -- Define Unit Cost of Flow on Path j for Demand i --
    param cost: {0} :=
    {1}\t;
    """.format(path_seq, matrix_str)
    
    fopen = open(ampl_data_file, 'a')
    fopen.write(flow_cost_param)
    fopen.close()

def count_hop(path):
    """
    This function is to count the number of hops along a path
    The input is in form of 'a_b_c_d', and the output should be 3
    """
    return path.count('_')
    
def load_gen(load_type='nonuniform', demand_value=(1,0)):
    """
    this function generates load based on the load type specification
    demand_value = (a,b)
    """
    if load_type == 'nonuniform':
        mean, std = demand_value
        load = random.lognormvariate(mean, std)/1000000
        #print "LOAD", load
        #print "LOGNORMAL", load
    elif load_type == 'nonuniformh':
        fixed, error = demand_value
        load1 = fixed + random.random() * error
        load2 = fixed - random.random() * error
        load = random.choice([load1, load2])
    load = round(load, 5)
    return load
    
def uniform_special_dpair(matrix_str, s_dpair, d_pairs, s_dvalue):
    """
    this function searches the special demand pair, and replace
    the special demand value in the matrix
    s_dpair
    """
    "SPECIAL PAIRS"
    # get the index for the demand pair in the matrix_str
    #print "s_dpair", s_dpair
    index = d_pairs.index(s_dpair) + 1
    #print "INDEX", index
    pattern = ''+ str(index) + '\t\t'
    start = matrix_str.find(pattern)
    end = start + len(pattern) + 1
    orig_value = matrix_str[start:end]
    #print "ORIG:", orig_value, "END"
    new_matrix_str = matrix_str.replace(orig_value, pattern + str(s_dvalue), 1)
    
    #print new_matrix_str
    return new_matrix_str
    
def nonuniform_special_dpair(matrix_str, s_dpair, d_pairs, s_dvalue):
    """
    this function searches the special demand pair, and replace
    the special demand value in the matrix
    s_dpair
    """
    # get the index for the demand pair in the matrix_str
    index = d_pairs.index(s_dpair) + 1
    pattern = str(index) + '\t\t'
    start = matrix_str.find(pattern)
    end = start + len(pattern) + 7
    orig_value = matrix_str[start:end]
    #print "pattern", pattern
    #print "s_dvalue", s_dvalue
    new_matrix_str = matrix_str.replace(orig_value, 
                                        pattern + str(s_dvalue))
    #print new_matrix_str
    return new_matrix_str    

def load_json(json_file):
    ''' load json file '''
    json_data = open(json_file)
    demand_info = json.loads(json_data.read())
    json_data.close()
    demand_dict = {}
    for item in demand_info:
        demand_dict[eval(item)] = demand_info[item]
    return demand_dict
    
    

def print_geant_demand_per_pair(ampl_data_file, demand_dict):
    """
    print traffic demand for geant node pairs, the demand information 
    is imported from the demand file (.json), the seed value represents 
    the date when the traffic is collected
    """
    d_pairs = demand_dict.keys()
    d_pairs.sort()
    matrix_str = ''
    for index in range(len(d_pairs)):
        key = d_pairs[index]
        demand = demand_dict[key]
        if index == 0:
            temp_str = '\t\t'.join([str(index + 1), str(demand)]) + '\n'
        else:
            temp_str = '\t' + '\t\t'.join([str(index + 1), 
                                              str(demand)]) + '\n'
        matrix_str = matrix_str + temp_str
    
    demand_param = """
    param h :=
    {0}\t;
    """.format(matrix_str)   
    
    fopen = open(ampl_data_file, 'a')
    fopen.write(demand_param)
    fopen.close()
    
    
    


def print_demand_per_pair(ampl_data_file, path_dict, 
                          demand_type, demand_value,
                          sub_dmd=None, s_dpair=None, seed_val=2):
    """
    print the demand request per demand pair
    demand_type is uniform or non-uniform
    uniorm: fixed demand for every pair
    demand_value is in form of tuple: (a, b)
    If demand_type is uniform, b = 0, demand = a
    if demand_type is uniforme1N or uniformeij, b=100, a=1, 
        one specital pair=b
    If demand_type is nonuniform, demand = a +/- b*rand()
    """
    if sub_dmd == None:
        d_allpairs = path_dict.keys()
    else: 
        d_allpairs = sub_dmd
    d_allpairs.sort()
    
    if demand_type == 'uniform' or demand_type == 'uniforme1n' \
        or demand_type == 'uniformeij':
        # uniform load
        demand = demand_value[0]
        matrix_str = ''
        for index in range(len(d_allpairs)):
            if index == 0:
                temp_str = '\t\t'.join([str(index + 1), 
                                        str(demand)]) + '\n'
            else:
                temp_str = '\t' + '\t\t'.join([str(index + 1), 
                                              str(demand)]) + '\n'
            matrix_str = matrix_str + temp_str
        if demand_type != 'uniform':
            # one pair with large load
            #print "uniform special case"
            matrix_str = uniform_special_dpair(matrix_str, s_dpair, 
                                               d_allpairs, demand_value[1])
            #print matrix_str        
    elif demand_type == 'nonuniform':
        # demand is randomly assigned, and it's uniformly distributed 
        # between 0.5 and 1.5
        random.seed(seed_val)
        matrix_str = ''
        #print "DEMAND_VALUE:", demand_value
        for index in range(len(d_allpairs)):
            if index == 0:
                #print demand_value
                demand = load_gen(demand_type, demand_value)
                #print demand
                temp_str = '\t\t'.join([str(index + 1), str(demand)]) + '\n'
            else:
                demand = load_gen(demand_type, demand_value)
                #print demand
                temp_str = '\t' + '\t\t'.join([str(index + 1), 
                                              str(demand)]) + '\n'
            matrix_str = matrix_str + temp_str
            #print matrix_str
    elif demand_type == 'nonuniformh':
        # each demand slightly varies from each other, and the error is 
        # demand_value[1]
        random.seed(seed_val)
        matrix_str = ''
        for index in range(len(d_allpairs)):
            if index == 0:
                demand = load_gen(demand_type, demand_value)
                temp_str = '\t\t'.join([str(index + 1), str(demand)]) + '\n'
            else:
                demand = load_gen(demand_type, demand_value)
                temp_str = '\t' + '\t\t'.join([str(index + 1), 
                                              str(demand)]) + '\n'
            matrix_str = matrix_str + temp_str
    elif demand_type == 'nonuniforme1n' or demand_type == 'nonuniformeij':
        random.seed(seed_val)
        matrix_str = ''
        for index in range(len(d_allpairs)):
            avg = round(demand_value[0] + random.random()*0.05, 5)       
            #print avg
            if index == 0:
                temp_str = '\t\t'.join([str(index + 1), str(avg)]) + '\n'
            else:
                temp_str = '\t' + '\t\t'.join([str(index + 1), 
                                              str(avg)]) + '\n'
            matrix_str = matrix_str + temp_str
        #print "uniform special case"
        big = round(demand_value[1] + random.random()*0.05, 5)
        matrix_str = nonuniform_special_dpair(matrix_str, s_dpair, 
                                   d_allpairs, big)
        #print matrix_str
        
    demand_param = """
    param h :=
    {0}\t;
    """.format(matrix_str)   
    
    fopen = open(ampl_data_file, 'a')
    fopen.write(demand_param)
    fopen.close()

def print_path_set(ampl_data_file, path_dict, link_dict, sub_dmd=None):
    """
    Print the path sets: the format is 
    set paths[d_id, path_id] := link_array
    for example: set paths[1,2] := 2 3
    """
    pattern1 = 'set paths'
    pattern2 = ' := '
    
    if sub_dmd == None:
        d_allpairs = path_dict.keys()
    else:
        d_allpairs = sub_dmd
    d_allpairs.sort()
    
    fopen = open(ampl_data_file, 'a')
    #print path_dict
    matrix_str = ''
    for index in range(len(d_allpairs)):
        #print d_allpairs
        dmd = d_allpairs[index]
        # debug
        for path_id in path_dict[dmd]:
            d_p = [index + 1, path_id]
            link_ids = get_link_id_list(path_dict[dmd][path_id], link_dict)
            temp_str = pattern1 + str(d_p) + pattern2 + ' '.join(link_ids) + ';\n'
            fopen.write(temp_str)
            #print index, d_p, temp_str
            #debug
            #if dmd==(1,5):
            #    print "DMD_ID, DMD, PATH_ID, D_P, LINK_ID", index+1, dmd, path_id, d_p, link_ids
            matrix_str = matrix_str + temp_str
  
    fopen.close()       
        
    
    
def get_link_id_list(path, link_dict):
    """
    Get the link array that contains the links along a given path
    For exampe: path = '1_2_3_4'
    link_dict = {1:(1,2), 2:(2,3), 3:(3,4), 4:(4,5)}
    this function returns to [1,2,3]
    """
    node_seq = path.split('_')
    link_seq = get_link_seq(node_seq)
    link_id_list = []
    for link in link_seq:
        src, dst = link
        temp = (max(src,dst), min(src,dst))
        link_id = [k for k, v in link_dict.iteritems() if v == temp][0]
        link_id_list.append(link_id)
    return map(str, link_id_list)
        
            
    
   
def get_link_seq(node_seq):
    """
    convert a node_list into a sequence of link
    for example: 
    node_seq = ['1', '2', '6','10']
    link_seq = [(1,2), (2,6), (6,10)]
    """
    node_seq_int = map(int, node_seq)
    link_seq = []
    for index in range(len(node_seq_int) - 1):
        link_tuple = (node_seq_int[index], node_seq_int[index + 1])
        link_seq.append(link_tuple)
    return link_seq
    
def print_coefficient(ampl_data_file):
    """
    for average network delay model only:
    co_y and co_c
    """
    toprint = """
    param co_y :=
    1 1.5
    2 4.5
    3 15
    4 50
    5 200
    6 4000;

    param co_c :=
    1 0
    2 1
    3 8
    4 36
    5 171
    6 3781;
    """
    fopen = open(ampl_data_file, 'a')
    fopen.write(toprint)
    fopen.close()
    
#def dryrun(model_type='mcr'):
#    """
#    For Debug
#    """
#    # input, output file names
#    ampl_data_file = "ampl_test.dat"
#    path_lib = "topo_info/path/grid_4_4_path.txt"
#    weight_csv = 'topo_info/topo_csv/grid_4_4.csv'
#    
#    # parse input files
#    link_dict = get_links(weight_csv)
#    num_nodes, p_dict = parse_file(path_lib)
#    
#    # model relavent parameters
#    #model_type = 'mcr'
#    topo_type = 'grid'
#    demand_type = 'uniform'
#    cost_type = 'byhops'
#    num_paths = 5
#    link_capacity = 100
#    
#    d_allpair = p_dict.keys()
#    
#    print_header(ampl_data_file, 
#                 model_type, 
#                 topo_type, 
#                 num_nodes, 
#                 demand_type)
#                 
#    print_boundary(ampl_data_file, 
#                   num_paths, 
#                   num_nodes, 
#                   link_dict, 
#                   d_allpair)
#    
#    print_link_node_pair(ampl_data_file, link_dict)
#    print_demand_node_pair(ampl_data_file, d_allpair, sub_dmd)
#    print_link_capacity(ampl_data_file, link_dict, link_capacity)
#    if model_type == "mcr":
#        # for mcr model only
#        print_flow_cost(ampl_data_file, p_dict, cost_type, num_paths)
#    elif model_type == "lb":
#        pass
#    elif model_type == "ad":
#        print_coefficient(ampl_data_file)
#        
#    print_demand_per_pair(ampl_data_file, p_dict, demand_type, (1,0))
#    print_path_set(ampl_data_file, p_dict, link_dict)
    
    
    
#def create_option(parser):
#    """
#    add the options to the parser:
#    takes arguments from commandline
#    """
#    parser.add_option("-v", action="store_true",
#                      dest="verbose",
#                      help="Print output to screen")
#    parser.add_option("-w", dest="ampl_data_file",
#                      type="str",
#                      default="ample_test.dat",
#                      help="Create ample data file")
#    parser.add_option("--pfile", dest="path_lib",
#                      type="str",
#                      default="path_test.txt",
#                      help="read the path file")
#    parser.add_option("--csv", dest="weight_csv",
#                      type="str",
#                      default="test_topo.csv",
#                      help="read topology csv file stores the adjacent matrix")
#    parser.add_option("-m", dest="model_type",
#                      type="str",
#                      default="mcr",
#                      help="minimum cost routing")
#    parser.add_option("-t", dest="topo_type",
#                      type="str",
#                      default="random",
#                      help="Topology type: random/grid/ring/full/rocketfuel")
#    parser.add_option("-d", dest="demand_type",
#                      type="str",
#                      default="uniform",
#                      help="Demand Type: uniform/nonuniform")
#    parser.add_option("-c", dest="cost_type",
#                      type="str",
#                      default="byhops",
#                      help="Type of cost of flow on path for each demand pair")
#    parser.add_option("--np", dest="num_paths",
#                      type="int",
#                      default="5",
#                      help="Number of path per demand pair")
#    parser.add_option("--lc", dest="link_capacity",
#                      type="int",
#                      default=100,
#                      help="Capacity for each link")
                      
def run(ampl_data_file, 
        path_lib, 
        weight_csv, 
        model_type, 
        topo_type,
        demand_type,
        num_paths,
        cost_type,
        link_capacity,
        sub_dmd,
        s_dpair,
        seed_val):
    """
    A program wrapper called by other python modeuls
    """                     
    link_dict = get_links(weight_csv)
    num_nodes, p_dict = parse_file(path_lib)
    if topo_type != 'geant':
        d_allpair = p_dict.keys()
    
    # generate seed
    #random.seed(seed_val)
    #print "CALL SEED FUN:", seed_val
    seed_dir = {37:5, 101:6, 239:7, 457:8, 919:9}    
    
    demand_value = ()
    if topo_type != 'geant':
        if demand_type == "uniform":
            demand_value = (1,0)
        elif demand_type == "uniforme1n" or demand_type == "uniformeij":
            demand_value = (1, 100)
        elif demand_type == "nonuniform":
            # log normal distribution
            demand_value = (16.6, 1.04)
        elif demand_type == "nonuniformh":
            demand_value = (100, 2)
        elif demand_type == "nonuniforme1n" or demand_type == "nonuniformeij":
            demand_value = (1, 100)
        else:
            demand_value = None
        print "demand_type", demand_type
        print "demand_value", demand_value
    else:
        if demand_type == "morning":
            demand_file = 'topo_info/geant_demand/geant_demand_2005050{0}_{1}.json'.format(seed_dir[seed_val], '0930')
        elif demand_type == "afternoon":
            demand_file = 'topo_info/geant_demand/geant_demand_2005050{0}_{1}.json'.format(seed_dir[seed_val], '1430')
        elif demand_type == "evening":
            demand_file = 'topo_info/geant_demand/geant_demand_2005050{0}_{1}.json'.format(seed_dir[seed_val], '2130')
        else:
            demand_file = None
        print "demand_type", demand_type
        print "demand_file", demand_file

    if topo_type == 'geant':
        demand_dict = load_json(demand_file)
        d_allpair = demand_dict.keys()
        print_header(ampl_data_file, 
                     model_type, 
                     topo_type, 
                     num_nodes, 
                     demand_type)
                 
        print_boundary(ampl_data_file, 
                       num_paths, 
                       num_nodes, 
                       link_dict, 
                       d_allpair,
                       sub_dmd)
        
        print_link_node_pair(ampl_data_file, link_dict)
        print_geant_demand_pair(ampl_data_file, demand_dict)
        print_geant_demand_per_pair(ampl_data_file, demand_dict)
        print_link_capacity(ampl_data_file, link_dict, link_capacity)
        
        if model_type == "mcr":
        # for mcr model only
            print_flow_cost(ampl_data_file, p_dict, cost_type, num_paths, 
                        d_allpair, seed_val)
        elif model_type == "lb":
            pass
        elif model_type == "ad":
            print_coefficient(ampl_data_file)
        
        print_path_set(ampl_data_file, p_dict, link_dict, d_allpair)

    else:
        print_header(ampl_data_file, 
                     model_type, 
                     topo_type, 
                     num_nodes, 
                     demand_type)
                 
        print_boundary(ampl_data_file, 
                       num_paths, 
                       num_nodes, 
                       link_dict, 
                       d_allpair,
                       sub_dmd)
       
        print_link_node_pair(ampl_data_file, link_dict)
        print_demand_node_pair(ampl_data_file, d_allpair, sub_dmd)
        print_link_capacity(ampl_data_file, link_dict, link_capacity)
    
    
    # pring data for different model type
        if model_type == "mcr":
        # for mcr model only
            print_flow_cost(ampl_data_file, p_dict, cost_type, num_paths, 
                        sub_dmd, seed_val)
        elif model_type == "lb":
            pass
        elif model_type == "ad":
            print_coefficient(ampl_data_file)

        print_demand_per_pair(ampl_data_file, p_dict, demand_type, 
                          demand_value, sub_dmd, s_dpair, seed_val)
        print_path_set(ampl_data_file, p_dict, link_dict, sub_dmd)
    
    
#def main(argv=None):
#    """
#    program wrapper
#    """
#    if not argv:
#        argv=sys.argv[1:]
#    usage = ("""%prog [-v verbose] 
#                    [-w ampl_data_file] 
#                    [--pfile path_lib] 
#                    [--csv weight_csv] 
#                    [-m model_type] 
#                    [-t topo_type]
#                    [-d demand_type]
#                    [-c cost_type]
#                    [--np num_paths]
#                    [--lc link_capacity]""")
#    parser = OptionParser(usage=usage)
#    create_option(parser)
#    (options, _) = parser.parse_args(argv)
#    ampl_data_file = options.ampl_data_file
#    path_lib = options.path_lib
#    weight_csv = options.weight_csv
#    model_type = options.model_type
#    topo_type = options.topo_type
#    demand_type = options.demand_type
#    cost_type = options.cost_type
#    num_paths = options.num_paths
#    link_capacity = options.link_capacity
#    
#    link_dict = get_links(weight_csv)
#    num_nodes, p_dict = parse_file(path_lib)
#    d_allpair = p_dict.keys()
#    
#    if demand_type == "uniform":
#        demand_value = (1, 0)
#    elif demand_type == "rand":
#        demand_value = (0.5, 1.5)
#    elif demand_type == "min":
#        demand_value = (1, 0.05)
#    elif demand_type == "max":
#        demand_value = (0.05, 1)
#        
#    print_header(ampl_data_file, 
#                 model_type, 
#                 topo_type, 
#                 num_nodes, 
#                 demand_type)
#                 
#    print_boundary(ampl_data_file, 
#                   num_paths, 
#                   num_nodes, 
#                   link_dict, 
#                   d_allpair)
#    
#    
#    print_link_node_pair(ampl_data_file, link_dict)
#    print_demand_node_pair(ampl_data_file, d_allpair)
#    print_link_capacity(ampl_data_file, link_dict, link_capacity)
#    
#    # pring data for different model type
#    if model_type == "mcr":
#        # for mcr model only
#        print_flow_cost(ampl_data_file, p_dict, cost_type, num_paths)
#    elif model_type == "lb":
#        pass
#    elif model_type == "ad":
#        print_coefficient(ampl_data_file)
#
#    print_demand_per_pair(ampl_data_file, p_dict, demand_type, demand_value)
#    print_path_set(ampl_data_file, p_dict, link_dict)
#    
#if __name__ == '__main__':
#    sys.exit(main()) 